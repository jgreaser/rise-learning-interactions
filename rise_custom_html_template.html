<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[Interaction Name]</title>
    
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         CONFIGURATION SECTION - EDIT THIS SECTION TO UPDATE CONTENT
         âš ï¸ LLM INSTRUCTION: When generating interactions, place ALL
         content data in this CONFIG object. Never hardcode content
         strings in the logic section. 
         
         Structure:
         - content: All learner-facing text and media
         - settings: Interaction behavior configuration
         - feedback: Response messages for learner actions
         - events: Declarative event tracking configuration
         
         âš ï¸ INSTRUCTIONAL DESIGNERS: This is the only section you need
         to edit to change quiz questions, feedback messages, or 
         interaction settings. Everything below this handles the logic. 
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <script>
        const CONFIG = {
            content: {
                // All learner-facing text, questions, images, etc.
                title: "Interaction Title",
                instructions: "Instructions for the learner",
                // Add your content structure here
            },
            settings: {
                // Behavior configuration (shuffle, attempts, scoring)
                // Add your settings here
            },
            feedback: {
                // Response messages
                correct: "Correct!",
                incorrect: "Try again.",
                // Add your feedback messages here
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // EVENTS CONFIGURATION
            // Define what events to track and where to send them
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            events: {
                // Master switch - set to false to disable all tracking
                enabled: true,
                
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // ANALYTICS CONFIGURATION
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                analytics: {
                    enabled: true,
                    provider: 'ga4', // 'ga4', 'gtm', 'none'
                    trackingId: '', // e.g., 'G-XXXXXXXXXX' for GA4
                    // Custom dimension mappings (optional)
                    customDimensions: {
                        // score: 'dimension1',
                        // outcome: 'dimension2'
                    }
                },
                
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // LMS CONFIGURATION
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                lms: {
                    enabled: true,
                    type: 'rise', // 'rise', 'scorm', 'xapi', 'custom', 'none'
                    completionThreshold: 0.7, // 0-1 (percentage of maxScore)
                    
                    // Custom LMS integration function (optional)
                    // Called when completion event fires
                    customHandler: null
                    // Example:
                    // customHandler: function(isComplete, data) {
                    //     console.log('Custom LMS handler', isComplete, data);
                    // }
                },
                
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // EVENT DEFINITIONS
                // Define which events to track in your interaction
                // The EventTracker will automatically fire these when triggered
                // If you have many of these interactions, for consistency you may 
                // want to provide more specific events to track
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                track: {
                    // Lifecycle events
                    lifecycle: {
                        started: {
                            enabled: true,
                            name: 'interaction_started',
                            data: {} // Additional data to include
                        },
                        completed: {
                            enabled: true,
                            name: 'interaction_completed',
                            includeScore: true,
                            includeTime: true
                        },
                        restarted: {
                            enabled: true,
                            name: 'interaction_restarted',
                            data: {}
                        }
                    },
                    
                    // Milestone events (major progress points)
                    // You may need to provide specific events
                    // so that you can compare analytics across 
                    // your various interactions
                    milestones: {
                        // Define your custom milestones here
                        // Examples:
                        // halfwayPoint: {
                        //     enabled: true,
                        //     name: 'reached_halfway',
                        //     trigger: 'manual' // 'manual' or 'auto'
                        // },
                        // allQuestionsAnswered: {
                        //     enabled: true,
                        //     name: 'all_questions_answered'
                        // }
                    },
                    
                    // User interaction events
                    interactions: {
                        // Examples of common interaction types:
                        // buttonClick: {
                        //     enabled: true,
                        //     name: 'button_clicked',
                        //     captureTarget: true, // Include which button
                        //     captureValue: false
                        // },
                        // questionAnswered: {
                        //     enabled: true,
                        //     name: 'question_answered',
                        //     captureCorrectness: true,
                        //     captureAttempts: true
                        // },
                        // choiceSelected: {
                        //     enabled: true,
                        //     name: 'choice_selected',
                        //     captureValue: true
                        // }
                    },
                    
                    // Score/performance events
                    performance: {
                        scoreChanged: {
                            enabled: true,
                            name: 'score_updated',
                            captureNewScore: true,
                            captureMaxScore: true
                        },
                        perfectScore: {
                            enabled: true,
                            name: 'perfect_score_achieved',
                            trigger: 'auto' // Fires automatically when score === maxScore
                        }
                    },
                    
                    // Feedback events
                    feedback: {
                        viewed: {
                            enabled: true,
                            name: 'feedback_shown',
                            captureType: true, // 'correct', 'incorrect', 'partial'
                            captureDuration: false
                        },
                        dismissed: {
                            enabled: true,
                            name: 'feedback_dismissed'
                        }
                    },
                    
                    // Navigation events
                    navigation: {
                        // stepChanged: {
                        //     enabled: true,
                        //     name: 'step_changed',
                        //     captureFrom: true,
                        //     captureTo: true
                        // },
                        // backButton: {
                        //     enabled: true,
                        //     name: 'navigated_back'
                        // }
                    }
                },
                
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // ADVANCED OPTIONS
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                options: {
                    // Log events to console for debugging
                    // Or just leave it on for the Dev console users
                    // to find, they love a little inside baseball
                    debug: true,
                    
                    // Batch events before sending (reduces network calls)
                    batching: {
                        enabled: false,
                        maxSize: 10,
                        maxWait: 5000 // milliseconds
                    },
                    
                    // Include additional context with every event
                    globalData: {
                        // interactionType: 'quiz',
                        // module: 'module-1'
                    },
                    
                    // Custom event handlers - run on every event
                    customHandlers: [
                        // Example:
                        // function(eventName, eventData) {
                        //     console.log('Custom handler:', eventName, eventData);
                        // }
                    ]
                }
            }
        };
    </script>
    
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         STYLES SECTION
         Define all visual presentation here using CSS
         No inline styles in the LOGIC section
         Use CSS custom properties for themeable values

        âš ï¸ LLM INSTRUCTION: If no design direction is provided, ask
        the user if they have style guides available. Then proceed once
        you have some direction. 
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <style>
        :root {
            --primary-color: #2563eb;
            --success-color: #10b981;
            --error-color: #ef4444;
            --bg-color: #f9fafb;
            --text-color: #1f2937;
            --border-radius: 8px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
            background: var(--bg-color);
        }

        #app {
            max-width: 600px;
            margin: 0 auto;
        }

        /* Add your custom styles here */
    </style>
</head>
<body>
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         APPLICATION LOGIC
         âš ï¸ LLM INSTRUCTION: All code must follow the pattern below.
         âš ï¸ LLM INSTRUCTION: If you are being asked to troubleshoot
            this temlpate, take on the role of web browser/javascript 
            interpreter, and trace the flow of activity from initial
            page load to the various user options available (button clicks, etc.)
            Be meticilous in your trouble-shooting, and use javascript
            patterns to solve the issues you find. 
         
         ARCHITECTURAL PATTERNS USED IN THIS TEMPLATE:
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         1. "Unidirectional Data Flow" (Flux/Redux Pattern)
            - STATE is single source of truth
            - Data flows: User Action â†’ Handler â†’ Update STATE â†’ render()
            - Never modify DOM directly, always update STATE then render()
         
         2. "Single Responsibility Principle"
            - Each function does ONE thing
            - render() only renders, handlers only handle events
            - Keep functions small (<30 lines ideal)
         
         3. "Declarative Rendering" (Virtual DOM Pattern)
            - Build entire UI from STATE each time
            - Use template literals for HTML generation
            - Don't try to update individual DOM elements
         
         4. "Event Delegation" (Attach listeners after render)
            - Listeners attached in attachEventListeners()
            - Called after every render() to rebind to new DOM
            - Use IDs and data attributes to identify elements
         
         5. "Separation of Concerns"
            - CONFIG: What (content and settings)
            - STATE: Current state of the interaction
            - render(): How to display STATE
            - Handlers: How STATE changes
            - Helpers: Reusable pure functions
         
         Required Structure:
         1. STATE object - single source of truth
         2. init() - setup and initial render
         3. render() - build/update UI from current state
         4. Event handlers - update state, then call render()
         5. Helper functions - pure functions when possible
         
         RULES:
         - Never manipulate DOM directly in event handlers
         - Always update STATE first, then call render()
         - Keep functions small and single-purpose
         - Use descriptive function names (verbs for actions)
         - Add comments explaining "why" not "what"
         
         EVENTS INTEGRATION:
         - Call EventTracker.fire() when significant actions occur
         - Use dot notation: EventTracker.fire('interactions.buttonClick')
         - Pass relevant data: EventTracker.fire('lifecycle.completed', { score: STATE.score })
         - Follow event patterns documented below to avoid infinite loops
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <script>
        // ============================================
        // STATE - Single source of truth
        // PATTERN: "Single Source of Truth" (SSOT Pattern)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // All application state lives here. Never store state in:
        // - DOM elements (data attributes, classes for state)
        // - Global variables outside STATE
        // - Component-level variables
        // 
        // Benefits:
        // - Predictable state updates
        // - Easy to debug (inspect STATE object)
        // - Time-travel debugging possible
        // - Easy to save/restore state
        // 
        // PATTERN: "Immutable Updates" (preferred)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // When updating arrays/objects, create new copies:
        // âœ… STATE.items = [...STATE.items, newItem]
        // âŒ STATE.items.push(newItem)
        // ============================================
        const STATE = {
            // Initialize state properties here
            currentStep: 0,
            score: 0,
            maxScore: 0,
            isComplete: false,
            
            // Event tracking flags - prevents duplicate events
            // PATTERN: "Guard Pattern" flags
            _eventFlags: {
                hasStarted: false,
                hasCompleted: false,
                // Add more flags as needed for one-time events
            }
            // Add your state properties
        };

        // ============================================
        // INITIALIZATION
        // PATTERN: "Initialization Pattern"
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Setup happens in this order:
        // 1. Initialize event tracking (if enabled)
        // 2. Process/prepare data (shuffle, filter, etc.)
        // 3. Set initial STATE values
        // 4. Call render() to display initial view
        // 
        // PATTERN: "Pure Functions for Data Processing"
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Use helper functions to transform CONFIG data:
        // âœ… STATE.questions = shuffleArray(CONFIG.content.questions)
        // âŒ Don't mutate CONFIG directly
        // ============================================
        function init() {
            // Initialize event tracking FIRST
            EventTracker.init();
            
            // Setup code goes here
            // - Shuffle content if needed
            // - Set up initial state
            // - Load saved progress if applicable
            
            render();
        }

        // ============================================
        // RENDERING
        // PATTERN: "Declarative Rendering" (React-style)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Build entire UI from STATE each time. Don't try to update
        // individual elements - regenerate everything.
        // 
        // PATTERN: "Template Literal Pattern"
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Use template literals (backticks) to build HTML strings
        // Interpolate STATE values with ${} syntax
        // 
        // PATTERN: "Render Pure" (No Side Effects)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // render() should ONLY build HTML from STATE
        // Don't fire events, don't update STATE, don't make API calls
        // 
        // âš ï¸ CRITICAL: NEVER fire events inside render()
        // render() can be called multiple times - events should only fire
        // when STATE changes, not when STATE is displayed
        // 
        // Flow: STATE â†’ render() â†’ HTML â†’ DOM â†’ attachEventListeners()
        // ============================================
        function render() {
            const app = document.getElementById('app');
            
            // PATTERN: "Conditional Rendering"
            // Show different views based on STATE
            // if (STATE.isComplete) return renderCompletionScreen();
            // if (STATE.showHelp) return renderHelpScreen();
            
            // Build HTML based on current STATE
            const html = `
                <div class="container">
                    <h1>${CONFIG.content.title}</h1>
                    <p>${CONFIG.content.instructions}</p>
                    <!-- Add your dynamic HTML here -->
                    
                    <!-- Example button that fires an event -->
                    <button id="exampleBtn">Click Me</button>
                </div>
            `;
            
            app.innerHTML = html;
            
            // PATTERN: "Event Delegation Setup"
            // Attach event listeners after DOM is updated
            attachEventListeners();
        }

        // ============================================
        // EVENT HANDLERS
        // PATTERN: "Event Handler Pattern"
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Standard flow for ALL event handlers:
        // 1. Extract data from event
        // 2. Update STATE (business logic)
        // 3. Fire tracking events (if needed)
        // 4. Call render() to reflect changes
        // 
        // PATTERN: "Data Flow: Unidirectional"
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // User Action â†’ Handler â†’ STATE Update â†’ Event Fire â†’ render() â†’ DOM Update
        // Never: DOM â†’ STATE (don't read from DOM to update STATE)
        // 
        // âš ï¸ KEY PRINCIPLES:
        // 1. Fire events in handlers, NEVER in render()
        // 2. Fire events BEFORE calling render()
        // 3. Use event flags for one-time events (start, complete)
        // 4. Fire repeatable events (clicks, inputs) directly
        // 5. Use transition helpers for state-change events
        // 
        // PATTERN: "Separation of Concerns"
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // attachEventListeners() - Binds handlers to DOM elements
        // handle*() - Contains business logic and STATE updates
        // ============================================
        function attachEventListeners() {
            // PATTERN: "Defensive Programming"
            // Always check if element exists before attaching listener
            // Elements might not exist in all views
            
            // Attach event listeners to dynamic elements
            const exampleBtn = document.getElementById('exampleBtn');
            if (exampleBtn) {
                exampleBtn.addEventListener('click', handleExampleClick);
            }
        }

        function handleExampleClick(event) {
            // PATTERN: "Handler Flow" - Follow this order:
            
            // 1. Extract relevant data from event
            const buttonId = event.target.id;
            
            // 2. Update STATE based on action (business logic)
            STATE.currentStep++;
            
            // 3. Fire tracking event (if configured)
            // PATTERN: "Idempotent Handler Pattern" - For repeatable events
            EventTracker.fire('interactions.buttonClick', {
                buttonId: buttonId,
                step: STATE.currentStep
            });
            
            // PATTERN: "Guard Pattern" - For one-time events, use flags:
            // if (!STATE._eventFlags.someEvent) {
            //     EventTracker.fire('milestones.someEvent', { data });
            //     STATE._eventFlags.someEvent = true;
            // }
            
            // Or use the helper:
            // fireOnce('milestones.someEvent', 'someEvent', { data });
            
            // 4. Re-render to show changes
            render();
        }

        // Example: Completing the interaction
        function handleComplete() {
            STATE.isComplete = true;
            
            // âš ï¸ CRITICAL PATTERN: Use event flags to prevent duplicate completion events
            // Problem: Completion events can fire multiple times if handleComplete is called repeatedly
            // Solution: Check flag before firing, set flag after firing
            if (!STATE._eventFlags.hasCompleted) {
                EventTracker.fire('lifecycle.completed', {
                    score: STATE.score,
                    maxScore: STATE.maxScore
                });
                STATE._eventFlags.hasCompleted = true;
            }
            
            render();
        }

        // ============================================
        // EVENT TRACKING PATTERNS & BEST PRACTICES
        // These are established JavaScript patterns adapted for event tracking
        // ============================================
        
        /**
         * PATTERN 1: "Guard Pattern" (One-Time Events)
         * Also known as: Flag Pattern, Once Pattern
         * 
         * Use for: Lifecycle events that should only fire once (start, complete, achievement unlocked)
         * 
         * Problem: Events fire multiple times when state changes repeatedly or render() is called
         * Solution: Use boolean guards/flags in STATE._eventFlags to ensure single execution
         * 
         * âœ… CORRECT Implementation:
         * if (!STATE._eventFlags.hasCompleted) {
         *     EventTracker.fire('lifecycle.completed', { data });
         *     STATE._eventFlags.hasCompleted = true;  // Set guard/flag
         * }
         * 
         * When to use: start, complete, restart, achievement_unlocked, milestone_reached
         */
        
        /**
         * PATTERN 2: "Command Pattern" (Action/Handler Events)
         * Also known as: Event-Command Pattern
         * 
         * Use for: User interactions and state transitions
         * 
         * Problem: Events fire during render loops instead of when user acts
         * Solution: Fire events in event handlers BEFORE calling render(), not during render()
         * 
         * âœ… CORRECT - Fire in handler:
         * function handleNext() {
         *     STATE.currentStep++;                                    // 1. Update state
         *     EventTracker.fire('step_changed', { step: STATE.currentStep }); // 2. Fire event
         *     render();                                               // 3. Re-render
         * }
         * 
         * âŒ INCORRECT - Fire in render:
         * function render() {
         *     if (STATE.currentStep > previousStep) {
         *         EventTracker.fire('step_changed'); // DON'T DO THIS - causes infinite loops
         *     }
         * }
         * 
         * When to use: button_clicked, next_clicked, choice_selected, answer_submitted
         */
        
        /**
         * PATTERN 3: "Observer Pattern" with Edge Detection (State-Change Events)
         * Also known as: State Transition Pattern, Edge Trigger Pattern
         * 
         * Use for: Events that fire when a condition becomes true (not while it stays true)
         * 
         * Problem: Checking state during render causes events to fire repeatedly every render
         * Solution: Detect state transitions by comparing previous state to current state
         * 
         * âœ… CORRECT - Detect transition:
         * function updateScore(points) {
         *     const wasPerfect = STATE.score === STATE.maxScore;  // Capture BEFORE
         *     STATE.score += points;                              // Change state
         *     const isNowPerfect = STATE.score === STATE.maxScore; // Check AFTER
         *     
         *     if (!wasPerfect && isNowPerfect) {                  // Fire on TRANSITION
         *         EventTracker.fire('perfect_score');
         *     }
         *     render();
         * }
         * 
         * âŒ INCORRECT - Check state without transition:
         * function render() {
         *     if (STATE.score === STATE.maxScore) {
         *         EventTracker.fire('perfect_score'); // Fires EVERY render when true!
         *     }
         * }
         * 
         * When to use: perfect_score, threshold_reached, all_correct, halfway_complete
         */
        
        /**
         * PATTERN 4: "Idempotent Handler Pattern" (Repeatable Events)
         * Also known as: Direct Fire Pattern
         * 
         * Use for: Events that SHOULD fire every time an action occurs
         * 
         * These events are intentionally repeatable - no flag or guard needed
         * Fire directly in event handlers each time they're called
         * 
         * âœ… CORRECT - Fire every time:
         * function handleButtonClick(event) {
         *     EventTracker.fire('button_clicked', { buttonId: event.target.id });
         *     // Process the action
         *     render();
         * }
         * 
         * function handleInput(event) {
         *     STATE.inputValue = event.target.value;
         *     EventTracker.fire('input_changed', { value: STATE.inputValue });
         *     render();
         * }
         * 
         * When to use: button_clicked, input_changed, item_clicked, tab_switched
         */
        
        /**
         * PATTERN 5: "Reset Pattern" (State Cleanup)
         * Also known as: Flag Reset Pattern
         * 
         * Use for: Resetting event flags when restarting or resetting the interaction
         * 
         * When users restart, some events should be able to fire again
         * Clear the relevant flags to allow this
         * 
         * âœ… CORRECT - Reset flags selectively:
         * function handleRestart() {
         *     // Reset event flags for events that should fire again
         *     STATE._eventFlags.hasCompleted = false;
         *     STATE._eventFlags.hasReachedHalfway = false;
         *     
         *     // Keep hasStarted = true (we don't fire "started" again)
         *     
         *     // Reset other state
         *     STATE.isComplete = false;
         *     STATE.currentStep = 0;
         *     
         *     // Fire restart event
         *     EventTracker.fire('lifecycle.restarted', { previousProgress: STATE.currentStep });
         *     
         *     render();
         * }
         * 
         * When to use: In restart/reset handlers
         */
        
        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * HELPER FUNCTIONS - Pre-built Pattern Implementations
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         */
        
        /**
         * Helper: Implements Guard Pattern automatically
         * Use this for one-time events to avoid manual flag management
         * 
         * @param {string} eventPath - Dot-notation path to event (e.g., 'lifecycle.completed')
         * @param {string} eventKey - Unique key for the flag (e.g., 'hasCompleted')
         * @param {object} data - Additional data to send with event
         * 
         * Example:
         * fireOnce('lifecycle.completed', 'hasCompleted', { score: STATE.score });
         */
        function fireOnce(eventPath, eventKey, data = {}) {
            if (!STATE._eventFlags[eventKey]) {
                EventTracker.fire(eventPath, data);
                STATE._eventFlags[eventKey] = true;
            }
        }
        
        /**
         * Helper: Implements Observer Pattern with Edge Detection automatically
         * Use this for events that should fire when a condition becomes true
         * 
         * @param {string} eventPath - Dot-notation path to event
         * @param {string} conditionKey - Unique key for tracking this condition
         * @param {boolean} isConditionMet - Whether the condition is currently true
         * @param {object} data - Additional data to send with event
         * 
         * Example:
         * fireOnTransition('milestones.perfect_score', 'perfectScore', 
         *                  STATE.score === STATE.maxScore, { score: STATE.score });
         */
        function fireOnTransition(eventPath, conditionKey, isConditionMet, data = {}) {
            const wasMetKey = `_was_${conditionKey}`;
            const wasMet = STATE._eventFlags[wasMetKey] || false;
            
            if (!wasMet && isConditionMet) {
                EventTracker.fire(eventPath, data);
            }
            
            STATE._eventFlags[wasMetKey] = isConditionMet;
        }
        
        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * QUICK REFERENCE - Which Pattern When?
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * 
         * Event Type                    â†’ Pattern to Use
         * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         * Lifecycle (start/complete)    â†’ Guard Pattern (fireOnce)
         * User action (click/input)     â†’ Command Pattern (direct fire)
         * Achievement/milestone         â†’ Observer Pattern (fireOnTransition)
         * State threshold reached       â†’ Observer Pattern (fireOnTransition)
         * Button click                  â†’ Idempotent Handler (direct fire)
         * Restart/reset                 â†’ Reset Pattern (clear flags)
         * 
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * ANTI-PATTERNS - DO NOT DO THESE
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * 
         * âŒ Firing events inside render():
         *    function render() {
         *        if (STATE.isComplete) {
         *            EventTracker.fire('completed'); // INFINITE LOOP!
         *        }
         *    }
         * 
         * âŒ Firing one-time events without guards:
         *    function handleComplete() {
         *        EventTracker.fire('completed'); // Fires multiple times!
         *        STATE.isComplete = true;
         *        render();
         *    }
         * 
         * âŒ Using guards for repeatable events:
         *    function handleClick() {
         *        if (!STATE._eventFlags.hasClicked) { // Wrong! Should fire each click
         *            EventTracker.fire('clicked');
         *            STATE._eventFlags.hasClicked = true;
         *        }
         *    }
         * 
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         */

        // ============================================
        // HELPER FUNCTIONS
        // PATTERN: "Pure Functions" (Functional Programming)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Helper functions should be "pure" when possible:
        // - Same input always produces same output
        // - No side effects (don't modify STATE, DOM, or external vars)
        // - Don't fire events or call render()
        // 
        // Benefits:
        // - Easy to test
        // - Easy to reuse
        // - Predictable behavior
        // - Can be moved to separate utility files
        // 
        // PATTERN: "Utility Functions"
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Common utilities to include:
        // - Data transformation (filter, map, sort)
        // - Validation (checkAnswer, validateInput)
        // - Formatting (formatTime, formatScore)
        // - Calculations (calculateScore, getProgress)
        // - Array manipulation (shuffle, chunk, sample)
        // 
        // Keep these pure (no side effects) when possible
        // ============================================
        
        /**
         * PATTERN: "Fisher-Yates Shuffle Algorithm"
         * Standard algorithm for randomizing array order
         * Creates a new array (doesn't mutate original)
         * 
         * Example helper function
         * @param {Array} array - Items to shuffle
         * @returns {Array} New shuffled array
         */
        function shuffleArray(array) {
            const shuffled = [...array]; // Create copy (don't mutate original)
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Add your helper functions here
        // Examples of common helpers:
        
        /**
         * PATTERN: "Validation Function"
         * Pure function that returns boolean
         */
        // function isAnswerCorrect(userAnswer, correctAnswer) {
        //     return userAnswer.trim().toLowerCase() === correctAnswer.trim().toLowerCase();
        // }
        
        /**
         * PATTERN: "Transformation Function"
         * Takes input, returns transformed output
         */
        // function formatTime(seconds) {
        //     const mins = Math.floor(seconds / 60);
        //     const secs = seconds % 60;
        //     return `${mins}:${secs.toString().padStart(2, '0')}`;
        // }
        
        /**
         * PATTERN: "Calculation Function"
         * Performs calculation, returns result
         */
        // function calculateScore(correct, total) {
        //     return total > 0 ? Math.round((correct / total) * 100) : 0;
        // }

        // ============================================
        // START APPLICATION
        // ============================================
        document.addEventListener('DOMContentLoaded', init);
    </script>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         MARKUP
         Minimal structure - most HTML generated by render()
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="app"></div>
    
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         EVENT TRACKING SYSTEM
         Automatically handles all event tracking based on CONFIG.events
         This is placed at the bottom to keep the main logic readable.
         The EventTracker object is hoisted and available throughout.
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <script>
        // ============================================
        // EVENT TRACKER - Declarative Event System
        // ============================================
        const EventTracker = {
            sessionId: null,
            startTime: null,
            eventQueue: [],
            eventLog: [],
            batchTimeout: null,
            
            /**
             * Initialize the event tracking system
             */
            init() {
                if (!CONFIG.events?.enabled) {
                    console.log('[EventTracker] Tracking disabled');
                    return;
                }
                
                this.sessionId = this.generateSessionId();
                this.startTime = Date.now();
                
                // Initialize analytics provider
                if (CONFIG.events.analytics?.enabled) {
                    this.initAnalytics();
                }
                
                // Fire started event if configured
                if (CONFIG.events.track?.lifecycle?.started?.enabled) {
                    this.fire('lifecycle.started');
                }
                
                // Setup beforeunload to capture exit
                window.addEventListener('beforeunload', () => {
                    this.fire('lifecycle.exited', {
                        duration: Date.now() - this.startTime
                    });
                    this.flush(); // Send any pending events
                });
                
                if (CONFIG.events.options?.debug) {
                    console.log('[EventTracker] Initialized', {
                        sessionId: this.sessionId,
                        config: CONFIG.events
                    });
                }
            },
            
            /**
             * Generate unique session ID
             */
            generateSessionId() {
                return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            },
            
            /**
             * Initialize analytics provider (Google Analytics, etc.)
             */
            initAnalytics() {
                const analytics = CONFIG.events.analytics;
                
                // Privacy notice
                console.log('[EventTracker] Analytics enabled - PII is not collected');
                
                if (analytics.provider === 'ga4' && analytics.trackingId) {
                    // Load Google Analytics
                    const script = document.createElement('script');
                    script.async = true;
                    script.src = `https://www.googletagmanager.com/gtag/js?id=${analytics.trackingId}`;
                    document.head.appendChild(script);
                    
                    window.dataLayer = window.dataLayer || [];
                    window.gtag = function() { dataLayer.push(arguments); };
                    gtag('js', new Date());
                    gtag('config', analytics.trackingId);
                    
                    if (CONFIG.events.options?.debug) {
                        console.log('[EventTracker] GA4 initialized:', analytics.trackingId);
                    }
                } else if (analytics.provider === 'gtm' && analytics.trackingId) {
                    // Google Tag Manager
                    window.dataLayer = window.dataLayer || [];
                    window.dataLayer.push({
                        'gtm.start': new Date().getTime(),
                        event: 'gtm.js'
                    });
                    
                    const script = document.createElement('script');
                    script.async = true;
                    script.src = `https://www.googletagmanager.com/gtm.js?id=${analytics.trackingId}`;
                    document.head.appendChild(script);
                }
            },
            
            /**
             * Fire an event based on its path in the config
             * @param {string} eventPath - Dot-notation path (e.g., 'lifecycle.started', 'interactions.buttonClick')
             * @param {object} additionalData - Extra data to include with the event
             */
            fire(eventPath, additionalData = {}) {
                if (!CONFIG.events?.enabled) return;
                
                // Navigate to the event definition in config
                const eventDef = this.getEventDefinition(eventPath);
                
                if (!eventDef || !eventDef.enabled) {
                    if (CONFIG.events.options?.debug) {
                        console.log(`[EventTracker] Event not enabled: ${eventPath}`);
                    }
                    return;
                }
                
                // Build event data
                const eventData = this.buildEventData(eventDef, additionalData);
                const eventName = eventDef.name || eventPath.replace(/\./g, '_');
                
                // Log the event
                this.logEvent(eventName, eventData);
                
                // Send to destinations
                this.send(eventName, eventData);
                
                // Check for auto-triggered events
                this.checkAutoTriggers(eventName, eventData);
            },
            
            /**
             * Get event definition from config by path
             */
            getEventDefinition(path) {
                const parts = path.split('.');
                let current = CONFIG.events.track;
                
                for (const part of parts) {
                    if (!current || !current[part]) return null;
                    current = current[part];
                }
                
                return current;
            },
            
            /**
             * Build event data object with all configured fields
             */
            buildEventData(eventDef, additionalData) {
                const data = {
                    sessionId: this.sessionId,
                    timestamp: Date.now(),
                    timeElapsed: Date.now() - this.startTime,
                    ...CONFIG.events.options?.globalData,
                    ...eventDef.data,
                    ...additionalData
                };
                
                // Add score if configured
                if (eventDef.includeScore && typeof STATE.score !== 'undefined') {
                    data.score = STATE.score;
                    data.maxScore = STATE.maxScore || 0;
                }
                
                // Add time if configured
                if (eventDef.includeTime) {
                    data.duration = Date.now() - this.startTime;
                }
                
                return data;
            },
            
            /**
             * Log event to internal array
             */
            logEvent(eventName, eventData) {
                this.eventLog.push({
                    name: eventName,
                    data: eventData,
                    timestamp: Date.now()
                });
                
                if (CONFIG.events.options?.debug) {
                    console.log(`[EventTracker] ğŸ“Š ${eventName}`, eventData);
                }
            },
            
            /**
             * Send event to configured destinations
             */
            send(eventName, eventData) {
                // Batching logic
                if (CONFIG.events.options?.batching?.enabled) {
                    this.eventQueue.push({ eventName, eventData });
                    
                    if (this.eventQueue.length >= CONFIG.events.options.batching.maxSize) {
                        this.flush();
                    } else {
                        this.scheduleBatchFlush();
                    }
                    return;
                }
                
                // Send immediately
                this.sendToAnalytics(eventName, eventData);
                this.sendToLMS(eventName, eventData);
                this.sendToCustomHandlers(eventName, eventData);
            },
            
            /**
             * Schedule batch flush
             */
            scheduleBatchFlush() {
                if (this.batchTimeout) return;
                
                this.batchTimeout = setTimeout(() => {
                    this.flush();
                }, CONFIG.events.options.batching.maxWait);
            },
            
            /**
             * Flush event queue
             */
            flush() {
                if (this.eventQueue.length === 0) return;
                
                const events = [...this.eventQueue];
                this.eventQueue = [];
                
                events.forEach(({ eventName, eventData }) => {
                    this.sendToAnalytics(eventName, eventData);
                    this.sendToLMS(eventName, eventData);
                    this.sendToCustomHandlers(eventName, eventData);
                });
                
                if (this.batchTimeout) {
                    clearTimeout(this.batchTimeout);
                    this.batchTimeout = null;
                }
            },
            
            /**
             * Send to analytics provider
             */
            sendToAnalytics(eventName, eventData) {
                if (!CONFIG.events.analytics?.enabled) return;
                
                const provider = CONFIG.events.analytics.provider;
                
                try {
                    if (provider === 'ga4' && window.gtag) {
                        window.gtag('event', eventName, eventData);
                    } else if (provider === 'gtm' && window.dataLayer) {
                        window.dataLayer.push({
                            event: eventName,
                            ...eventData
                        });
                    }
                } catch (e) {
                    // Silently fail - don't let analytics errors crash the interaction
                    if (CONFIG.events.options?.debug) {
                        console.error('[EventTracker] Analytics error (non-critical):', e);
                    }
                }
            },
            
            /**
             * Send to LMS
             */
            sendToLMS(eventName, eventData) {
                if (!CONFIG.events.lms?.enabled) return;
                
                // Only send completion events to LMS
                if (eventName !== 'interaction_completed') return;
                
                const lmsType = CONFIG.events.lms.type;
                const threshold = CONFIG.events.lms.completionThreshold;
                const isComplete = eventData.score >= (eventData.maxScore * threshold);
                
                if (lmsType === 'rise') {
                    try {
                        if (isComplete) {
                            window.parent.postMessage({ type: 'complete' }, '*');
                            if (CONFIG.events.options?.debug) {
                                console.log('[EventTracker] ğŸ“¤ Sent completion to Rise');
                            }
                        }
                    } catch (e) {
                        console.error('[EventTracker] Error sending to Rise:', e);
                    }
                } else if (lmsType === 'scorm') {
                    this.sendToSCORM(isComplete, eventData);
                } else if (lmsType === 'xapi') {
                    this.sendToXAPI(isComplete, eventData);
                } else if (lmsType === 'custom' && CONFIG.events.lms.customHandler) {
                    CONFIG.events.lms.customHandler(isComplete, eventData);
                }
            },
            
            /**
             * SCORM integration
             */
            sendToSCORM(isComplete, eventData) {
                const API = window.API || window.API_1484_11;
                if (!API) return;
                
                try {
                    API.LMSSetValue('cmi.core.lesson_status', isComplete ? 'completed' : 'incomplete');
                    if (eventData.score !== undefined) {
                        const percentage = Math.round((eventData.score / eventData.maxScore) * 100);
                        API.LMSSetValue('cmi.core.score.raw', percentage);
                    }
                    API.LMSCommit('');
                    
                    if (CONFIG.events.options?.debug) {
                        console.log('[EventTracker] ğŸ“¤ SCORM data committed');
                    }
                } catch (e) {
                    console.error('[EventTracker] Error with SCORM:', e);
                }
            },
            
            /**
             * xAPI integration
             */
            sendToXAPI(isComplete, eventData) {
                if (!window.ADL?.XAPIWrapper) return;
                
                const statement = {
                    actor: {
                        mbox: "mailto:learner@example.com",
                        objectType: "Agent"
                    },
                    verb: {
                        id: isComplete ? 
                            "http://adlnet.gov/expapi/verbs/completed" : 
                            "http://adlnet.gov/expapi/verbs/attempted",
                        display: { "en-US": isComplete ? "completed" : "attempted" }
                    },
                    object: {
                        id: window.location.href,
                        objectType: "Activity"
                    },
                    result: {
                        score: {
                            scaled: eventData.score / eventData.maxScore,
                            raw: eventData.score,
                            max: eventData.maxScore
                        },
                        success: isComplete,
                        completion: isComplete
                    }
                };
                
                try {
                    window.ADL.XAPIWrapper.sendStatement(statement);
                    if (CONFIG.events.options?.debug) {
                        console.log('[EventTracker] ğŸ“¤ xAPI statement sent');
                    }
                } catch (e) {
                    console.error('[EventTracker] Error with xAPI:', e);
                }
            },
            
            /**
             * Send to custom handlers
             */
            sendToCustomHandlers(eventName, eventData) {
                const handlers = CONFIG.events.options?.customHandlers || [];
                
                handlers.forEach(handler => {
                    try {
                        handler(eventName, eventData);
                    } catch (e) {
                        console.error('[EventTracker] Error in custom handler:', e);
                    }
                });
            },
            
            /**
             * Check for auto-triggered events (like perfect score)
             */
            checkAutoTriggers(eventName, eventData) {
                // Check for perfect score
                const perfectScoreDef = CONFIG.events.track?.performance?.perfectScore;
                if (perfectScoreDef?.enabled && 
                    perfectScoreDef.trigger === 'auto' &&
                    eventData.score === eventData.maxScore &&
                    eventData.maxScore > 0) {
                    
                    this.fire('performance.perfectScore', eventData);
                }
            },
            
            /**
             * Get all logged events
             */
            getEventLog() {
                return this.eventLog;
            },
            
            /**
             * Get session summary
             */
            getSessionSummary() {
                return {
                    sessionId: this.sessionId,
                    startTime: this.startTime,
                    duration: Date.now() - this.startTime,
                    eventCount: this.eventLog.length,
                    events: this.eventLog
                };
            }
        };
    </script>
</body>
</html>
